<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Quantum search · QuantumWalk</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../assets/logo.ico" rel="icon" type="image/x-icon"/></head><body><nav class="toc"><a href="../"><img class="logo" src="../assets/logo.png" alt="QuantumWalk logo"/></a><h1>QuantumWalk</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><a class="toctext" href="../type_hierarchy/">Type hierarchies</a></li><li><span class="toctext">Dynamics</span><ul><li><a class="toctext" href="../quantum_walk/">Quantum walk evolution</a></li><li class="current"><a class="toctext" href>Quantum search</a><ul class="internal"><li><a class="toctext" href="#Quantum-Search-1">Quantum Search</a></li><li><a class="toctext" href="#Example-1">Example</a></li><li><a class="toctext" href="#Adjusting-model-to-QWSearch-1">Adjusting model to <code>QWSearch</code></a></li><li><a class="toctext" href="#Documentation-1">Documentation</a></li><li><a class="toctext" href="#Full-docs-1">Full docs</a></li></ul></li></ul></li><li><span class="toctext">Models</span><ul><li><a class="toctext" href="../ctqw/">CTQW and CTQWDense</a></li><li><a class="toctext" href="../szegedy/">Szegedy</a></li></ul></li><li><a class="toctext" href="../contributing/">Contributing</a></li><li><a class="toctext" href="../citing/">Citing</a></li><li><a class="toctext" href="../license/">Licence</a></li></ul></nav><article id="docs"><header><nav><ul><li>Dynamics</li><li><a href>Quantum search</a></li></ul><a class="edit-page" href="https://github.com/iitis/QuantumWalk.jl/blob/master/docs/src/quantum_search.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Quantum search</span><a class="fa fa-bars" href="#"></a></div></header><h2><a class="nav-anchor" id="Quantum-Search-1" href="#Quantum-Search-1">Quantum Search</a></h2><p>Quantum spatial search is an algorithm, which starts at some initial state (which  depends on the graph structure), and runs for some time in order to cumulate  amplitude at marked vertex. The algorithm is known to outperform classical search.</p><p>The dynamics requires <code>evolve</code>, <code>measure</code>, <code>initial_state</code> and <code>check_qwdynamics</code> functions. It provides <code>execute</code>, <code>execute_single</code>, <code>execute_single_measured</code>, <code>execute_all</code> and <code>execute_all_measured</code> functions - the description can be found in <a href="../quantum_walk/">Quantum walk evolution</a> section. The only difference is that <code>QWSearch</code> uses the state generated by <code>initial_state</code> function if not provided. Furthermore the function provides <code>marked</code>, <code>penalty</code> and <code>maximize_quantum_search</code>. The first two returns the parameters from <code>QWSearch</code>. The last one searches for optimal measure time. The maximization methods depends on the model (if it is continuous or discrete).</p><p>The <code>penalty</code> is an additional time added in optimization. Note, that if we optimize  time/success_probability(time) function, the optimum is always at time 0. This would imply that algorithm achieves full efficiency if it is instantly measured. This is misleading, as the time for constructing initial state and for measurement is ignored.  Hence we need to include (usually small) additional time in <code>penalty</code> in order to  get useful result. Note the time/success_probability(time) is at called  <em>expected runtime</em> and can be obtained by <code>expected_runtime</code> function.</p><p>Some function as a result outputs <code>QSearchState</code> instead of the original state.  It consists of the original state, the runtime, the probability of measuring  each marked vertex, and penalty used for computing <code>QSearchState</code>. Those elements can be extracted by <code>state</code>, <code>runtime</code>, <code>probability</code> and <code>penalty</code> functions.</p><h2><a class="nav-anchor" id="Example-1" href="#Example-1">Example</a></h2><pre><code class="language-julia">julia&gt; n = 100;

julia&gt; penalty_szegedy = log(n);

julia&gt; qsearch = QWSearch(Szegedy(CompleteGraph(n)), [1], penalty_szegedy);

julia&gt; runtime(maximize_quantum_search(qsearch))-penalty_szegedy
5.0

julia&gt; probability(maximize_quantum_search(qsearch))
1-element Array{Float64,1}:
 0.569689

julia&gt; execute_single_measured(qsearch, ceil(Int, pi*sqrt(100)/2))
100-element Array{Float64,1}:
 0.428475  
 0.00577298
 0.00577298
 0.00577298
 0.00577298
 0.00577298
 0.00577298
 0.00577298
 0.00577298
 ⋮         
 0.00577298
 0.00577298
 0.00577298
 0.00577298
 0.00577298
 0.00577298
 0.00577298
 0.00577298
 0.00577298</code></pre><h2><a class="nav-anchor" id="Adjusting-model-to-QWSearch-1" href="#Adjusting-model-to-QWSearch-1">Adjusting model to <code>QWSearch</code></a></h2><p>Here we consider the example from the <a href="../quantum_walk/">Quantum walk evolution</a> section. We consider random walk search as follows: at given step we check if we are at the marked vertex. If not, we continue evolution. Hence we need to cumulate the success probability at marked vertices. We propose following implementation (including the functions from mentioned section). Again some additional assertion could be included for full functionality.</p><pre><code class="language-julia">function check_qwdynamics(::Type{QWSearch},
                          abs_stoch::UniformStochastic,
                          ::Vector{Int},
                          parameters::Dict{Symbol,Any})
  @assert :stochastic ∈ keys(parameters) &quot;parameters needs to have key stochastic&quot;
  n = nv(graph(abs_stoch))
  @assert isa(parameters[:stochastic], SparseMatrixCSC{&lt;:Real}) &quot;value for :stochastic needs to be sparse matrix with real numbers&quot;
  @assert size(parameters[:stochastic], 1) == size(parameters[:stochastic], 2) &quot;Stochastic matrix needs to be square stochastic matrix&quot;
  @assert mapslices(sum, parameters[:stochastic], 1)[1,:] ≈ ones(n) &quot;Stochastic matrix needs to be square stochastic matrix of order graph&quot;
end

function QWSearch(stoch::AbstractStochastic,
                  marked::Vector{Int},
                  penalty::Real = 0.)
   parameters = Dict{Symbol,Any}(:stochastic =&gt; stochastic_matrix(graph(stoch)))

   QWSearch(stoch, marked, parameters, penalty)
end

function initial_state(qws::QWSearch{&lt;:AbstractStochastic})
  n = nv(graph(qws))
  fill(1./n, n)
end

function evolve(qws::QWSearch{&lt;:AbstractStochastic}, state::Vector{&lt;:Real})
  old_probability = measure(qws, state, marked(qws))
  state[marked(qws)] = zero(marked(qws))
  state = stochastic_evolution(parameters(qws)[:stochastic], state)
  state[marked(qws)] += old_probability
  state
end</code></pre><p>Note that for example <code>measure</code> function does not change. Below we provide an evolution simulation example.</p><pre><code class="language-julia">julia&gt; dynamic = QWSearch(UniformStochastic(CompleteGraph(100)), [1])
QuantumWalk.QWSearch{UniformStochastic{LightGraphs.SimpleGraphs.SimpleGraph{Int64}},Float64}(UniformStochastic{LightGraphs.SimpleGraphs.SimpleGraph{Int64}}({100, 4950} undirected simple Int64 graph), [1], Dict{Symbol,Any}(Pair{Symbol,Any}(:stochastic,
  [2  ,   1]  =  0.010101
  [3  ,   1]  =  0.010101
  [4  ,   1]  =  0.010101
  [5  ,   1]  =  0.010101
  [6  ,   1]  =  0.010101
  ⋮
  [94 , 100]  =  0.010101
  [95 , 100]  =  0.010101
  [96 , 100]  =  0.010101
  [97 , 100]  =  0.010101
  [98 , 100]  =  0.010101
  [99 , 100]  =  0.010101)), 0.0)

julia&gt; measure(dynamic, execute_single(dynamic, 0), [1])
1-element Array{Float64,1}:
 0.01

julia&gt; measure(dynamic, execute_single(dynamic, 40), [1])
1-element Array{Float64,1}:
 0.340416

julia&gt; measure(dynamic, execute_single(dynamic, 1000), [1])
1-element Array{Float64,1}:
 0.999961</code></pre><h2><a class="nav-anchor" id="Documentation-1" href="#Documentation-1">Documentation</a></h2><p>Following functions are connected to the quantum search:</p><ul><li><a href="#QuantumWalk.QSearchState"><code>QuantumWalk.QSearchState</code></a></li><li><a href="#QuantumWalk.QWSearch"><code>QuantumWalk.QWSearch</code></a></li><li><a href="#QuantumWalk.execute-Tuple{QWSearch,Real}"><code>QuantumWalk.execute</code></a></li><li><a href="#QuantumWalk.execute_all-Union{Tuple{S}, Tuple{QWSearch{#s3,W} where W&lt;:Real where #s3&lt;:QWModelDiscr,S,Int64}} where S"><code>QuantumWalk.execute_all</code></a></li><li><a href="#QuantumWalk.execute_all_measured-Tuple{QWSearch{#s3,W} where W&lt;:Real where #s3&lt;:QWModelDiscr,Int64}"><code>QuantumWalk.execute_all_measured</code></a></li><li><a href="#QuantumWalk.execute_single-Tuple{QWSearch{#s3,W} where W&lt;:Real where #s3&lt;:QWModelDiscr,Any,Int64}"><code>QuantumWalk.execute_single</code></a></li><li><a href="#QuantumWalk.execute_single_measured-Tuple{QWSearch,Int64}"><code>QuantumWalk.execute_single_measured</code></a></li><li><a href="#QuantumWalk.expected_runtime-Tuple{Real,Real}"><code>QuantumWalk.expected_runtime</code></a></li><li><a href="#QuantumWalk.initial_state"><code>QuantumWalk.initial_state</code></a></li><li><a href="#QuantumWalk.marked-Tuple{QWSearch}"><code>QuantumWalk.marked</code></a></li><li><a href="#QuantumWalk.maximize_quantum_search-Tuple{QWSearch{#s3,W} where W&lt;:Real where #s3&lt;:QWModelCont}"><code>QuantumWalk.maximize_quantum_search</code></a></li><li><a href="#QuantumWalk.maximize_quantum_search-Tuple{QWSearch{#s3,W} where W&lt;:Real where #s3&lt;:QWModelDiscr}"><code>QuantumWalk.maximize_quantum_search</code></a></li><li><a href="#QuantumWalk.penalty-Tuple{QSearchState}"><code>QuantumWalk.penalty</code></a></li><li><a href="#QuantumWalk.penalty-Tuple{QWSearch}"><code>QuantumWalk.penalty</code></a></li><li><a href="#QuantumWalk.probability-Tuple{QSearchState}"><code>QuantumWalk.probability</code></a></li><li><a href="#QuantumWalk.runtime-Tuple{QSearchState}"><code>QuantumWalk.runtime</code></a></li><li><a href="#QuantumWalk.state-Tuple{QSearchState}"><code>QuantumWalk.state</code></a></li></ul><h2><a class="nav-anchor" id="Full-docs-1" href="#Full-docs-1">Full docs</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumWalk.QSearchState" href="#QuantumWalk.QSearchState"><code>QuantumWalk.QSearchState</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">QSearchState(state, probability, runtime, penalty)
QSearchState(qws, state, runtime)</code></pre><p>Creates container which consists of <code>state</code>, success probability <code>probability</code>, running time <code>runtime</code> and penalty <code>penalty</code>.</p><p>In second case <code>state</code> is measured according to <code>qws</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; qws = QWSearch(Szegedy(complete_graph(4)), [1]);

julia&gt; result = QSearchState(qws, initial_state(qws), 0)
QSearchState{Array{Float64,1},Int64,Int64}([0.0, 0.28867513459481287, 0.28867513459481287, 0.28867513459481287, 0.28867513459481287, 0.0, 0.28867513459481287, 0.28867513459481287, 0.28867513459481287, 0.28867513459481287, 0.0, 0.28867513459481287, 0.28867513459481287, 0.28867513459481287, 0.28867513459481287, 0.0], [0.25], 0, 0)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/iitis/QuantumWalk.jl/blob/22b2061f668a3431fab4dcee997f27bf853b9831/src/qwdynamics/qwsearch/qwsearch.jl#L80-L96">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumWalk.QWSearch" href="#QuantumWalk.QWSearch"><code>QuantumWalk.QWSearch</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">QWSearch(model, parameters, marked, penalty[; check])</code></pre><p>Simulates quantum search on <code>model</code> with <code>marked</code> vertices and additional <code>parameters</code>. <code>penalty</code> represents the cost of initial state creation and measurement, which should be included for better optimization, see documentation of <code>maximizing_function</code>. Note that marked vertices needs to be between <code>1</code> and <code>nv(graph(model))</code>. Furthermore penalty needs to be nonnegative.</p><p><code>check_qwdynamics</code> is executed if and only iff <code>check</code> is true.</p><p>Needs implementation of</p><ul><li><code>initial_state(qws::QWSearch)</code></li><li><code>evolve(qws::QWSearch{&lt;:QWModelDiscr}, state)</code> or <code>evolve(qws::QWSearch{&lt;:QWModelCont}, state, time::Real)</code></li><li><code>measure(qws::QWSearch, state[, vertices])</code></li><li><code>check_qwdynamics(QWSearch, model::QWModel, parameters::Dict{Symbol}, penalty::Real)</code></li><li>proper constructors.</li></ul><p>Offers functions</p><ul><li><code>execute</code></li><li><code>execute_single</code></li><li><code>execute_single_measured</code></li><li><code>execute_all</code></li><li><code>execute_all_measured</code></li><li><code>maximize_quantum_search</code>.</li></ul><p>It is encoureged to implement constructor, which changes the <code>penalty</code> and/or <code>marked</code> vertices only, as their are usually simple to adapt.</p></div></div><a class="source-link" target="_blank" href="https://github.com/iitis/QuantumWalk.jl/blob/22b2061f668a3431fab4dcee997f27bf853b9831/src/qwdynamics/qwsearch/qwsearch.jl#L11-L39">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumWalk.execute-Tuple{QWSearch,Real}" href="#QuantumWalk.execute-Tuple{QWSearch,Real}"><code>QuantumWalk.execute</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">execute(qws,[ initstate,] runtime[, all, measure])</code></pre><p>Run proper execution  of quantum spatial search depending on given keywords. The initial state is generated by <code>initial_state(qws)</code> if not provided. <code>all</code> and <code>measure</code> keywords defaults to <code>false</code>. For detailed description please see documentation of corresponding function, like <code>execute_single_measured</code> or <code>execute_all</code>. Note that for <code>all</code> equal to <code>true</code> model in <code>qws</code> needs to be disrete.</p></div></div><a class="source-link" target="_blank" href="https://github.com/iitis/QuantumWalk.jl/blob/22b2061f668a3431fab4dcee997f27bf853b9831/src/qwdynamics/qwsearch/qwsearch_dynamics.jl#L9-L19">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumWalk.execute_all-Union{Tuple{S}, Tuple{QWSearch{#s3,W} where W&lt;:Real where #s3&lt;:QWModelDiscr,S,Int64}} where S" href="#QuantumWalk.execute_all-Union{Tuple{S}, Tuple{QWSearch{#s3,W} where W&lt;:Real where #s3&lt;:QWModelDiscr,S,Int64}} where S"><code>QuantumWalk.execute_all</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">execute_all(qws,[ initstate,] runtime)</code></pre><p>Evolve <code>initstate</code> acording to <code>qws</code> for time <code>runtime</code>. <code>runtime</code> needs to be nonnegative. The initial state is generated by <code>initial_state(qws)</code> if not provided. Returns <code>Vector</code> of all <code>QSearchState{typeof(initstate)}</code> including <code>initstate</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/iitis/QuantumWalk.jl/blob/22b2061f668a3431fab4dcee997f27bf853b9831/src/qwdynamics/qwsearch/qwsearch_dynamics.jl#L79-L86">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumWalk.execute_all_measured-Tuple{QWSearch{#s3,W} where W&lt;:Real where #s3&lt;:QWModelDiscr,Int64}" href="#QuantumWalk.execute_all_measured-Tuple{QWSearch{#s3,W} where W&lt;:Real where #s3&lt;:QWModelDiscr,Int64}"><code>QuantumWalk.execute_all_measured</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">execute_all_measured(qws,[ initstate,] runtime)</code></pre><p>Evolve <code>initstate</code> acording to <code>qws</code> for time <code>runtime</code>. <code>runtime</code> needs to be nonnegative. The initial state is generated by <code>initial_state(qws)</code>  if not provided. As a result return matrix of type <code>Matrix{Float64}</code>  for which <code>i</code>-th column is measurement probability distribution in (<code>i-1</code>)-th step.</p></div></div><a class="source-link" target="_blank" href="https://github.com/iitis/QuantumWalk.jl/blob/22b2061f668a3431fab4dcee997f27bf853b9831/src/qwdynamics/qwsearch/qwsearch_dynamics.jl#L106-L113">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumWalk.execute_single-Tuple{QWSearch{#s3,W} where W&lt;:Real where #s3&lt;:QWModelDiscr,Any,Int64}" href="#QuantumWalk.execute_single-Tuple{QWSearch{#s3,W} where W&lt;:Real where #s3&lt;:QWModelDiscr,Any,Int64}"><code>QuantumWalk.execute_single</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">execute_single(qws, [ initstate,] runtime)</code></pre><p>Evolve <code>initstate</code> acording to <code>qws</code> for time <code>runtime</code>. The initial state is generated by <code>initial_state(qws)</code> if not provided. <code>runtime</code> needs to be nonnegative. <code>QSearchState{typeof(initstate)}</code> is returned.</p></div></div><a class="source-link" target="_blank" href="https://github.com/iitis/QuantumWalk.jl/blob/22b2061f668a3431fab4dcee997f27bf853b9831/src/qwdynamics/qwsearch/qwsearch_dynamics.jl#L35-L41">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumWalk.execute_single_measured-Tuple{QWSearch,Int64}" href="#QuantumWalk.execute_single_measured-Tuple{QWSearch,Int64}"><code>QuantumWalk.execute_single_measured</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">execute_single_measured(qws,[ initstate,] runtime)</code></pre><p>Evolve <code>initstate</code> acording to <code>qws</code> for time <code>runtime</code>. The initial state is generated by <code>initial_state(qws)</code> if not provided. <code>runtime</code> needs to be nonnegative. Measurement probability distribution is returned.</p></div></div><a class="source-link" target="_blank" href="https://github.com/iitis/QuantumWalk.jl/blob/22b2061f668a3431fab4dcee997f27bf853b9831/src/qwdynamics/qwsearch/qwsearch_dynamics.jl#L67-L73">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumWalk.expected_runtime-Tuple{Real,Real}" href="#QuantumWalk.expected_runtime-Tuple{Real,Real}"><code>QuantumWalk.expected_runtime</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">expected_runtime(runtime, probability)
expected_runtime(state)</code></pre><p>Returns the expected runtime needed for quantum walk, considering it as Bernoulli process. It equals to <code>runtime/probability</code>. In the case of <code>state</code> provided the measurement is made, penalty is included.</p></div></div><a class="source-link" target="_blank" href="https://github.com/iitis/QuantumWalk.jl/blob/22b2061f668a3431fab4dcee997f27bf853b9831/src/qwdynamics/qwsearch/qwsearch_util.jl#L23-L30">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumWalk.initial_state" href="#QuantumWalk.initial_state"><code>QuantumWalk.initial_state</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">initial_state(qws)</code></pre><p>Generates initial state for <code>qws</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/iitis/QuantumWalk.jl/blob/22b2061f668a3431fab4dcee997f27bf853b9831/src/qwdynamics/qwsearch/qwsearch.jl#L152-L156">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumWalk.marked-Tuple{QWSearch}" href="#QuantumWalk.marked-Tuple{QWSearch}"><code>QuantumWalk.marked</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">marked(qws)</code></pre><p>Returns <code>marked</code> vertices element of <code>qws</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/iitis/QuantumWalk.jl/blob/22b2061f668a3431fab4dcee997f27bf853b9831/src/qwdynamics/qwsearch/qwsearch.jl#L65-L69">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumWalk.maximize_quantum_search-Tuple{QWSearch{#s3,W} where W&lt;:Real where #s3&lt;:QWModelCont}" href="#QuantumWalk.maximize_quantum_search-Tuple{QWSearch{#s3,W} where W&lt;:Real where #s3&lt;:QWModelCont}"><code>QuantumWalk.maximize_quantum_search</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">maximize_quantum_search(qws_cont [, maxtime, tstep])</code></pre><p>Determines optimal runtime for continuous quantum walk search. The time is searched in [0, maxtime] interval, with penalty <code>penalty(qws_cont)</code>. It is recommended for penalty to be nonzero, otherwise time close to 0 is usually returned. Typically <code>penalty</code> equal to <code>log(nv(graph(qws_cont)))</code> is enough, but optimal value may depend on the model or graph chosen.</p><p>The optimal time is chosen according to expected runtime, which equals to runtime over probability. This comes from interpreting the evolution as the Bernoulli process.</p><p><code>tstep</code> is used for primary grid search to search for determine intervale which is supsected to have small expected runtime. To large value may miss the optimal value, while to small may greatly increase runtime of the algorithm.</p><p><code>maxtime</code> defaults to graph order n, <code>tstep</code> defaults to <code>sqrt(n)/5</code>. Note that in general the probability is not maximal.</p><pre><code class="language-julia-repl">julia&gt; qws = QWSearch(CTQW(complete_graph(100)), [1], 1., 0.01);

julia&gt; result = maximize_quantum_search(qws)
QSearchState{Array{Complex{Float64},1},Float64,Float64}(Complex{Float64}[0.6211421326794925 + 0.6956647632995185im, 0.027973603660103912 - 0.023085974674888862im, 0.027973603660103912 - 0.023085974674888862im, 0.027973603660103912 - 0.023085974674888862im, 0.027973603660103912 - 0.023085974674888862im, 0.027973603660103912 - 0.023085974674888862im, 0.027973603660103912 - 0.023085974674888862im, 0.027973603660103912 - 0.023085974674888862im, 0.027973603660103912 - 0.023085974674888862im, 0.027973603660103912 - 0.023085974674888862im  …  0.027973603660103912 - 0.023085974674888862im, 0.027973603660103912 - 0.023085974674888862im, 0.027973603660103912 - 0.023085974674888862im, 0.027973603660103912 - 0.023085974674888862im, 0.027973603660103912 - 0.023085974674888862im, 0.027973603660103912 - 0.023085974674888862im, 0.027973603660103895 - 0.023085974674888883im, 0.027973603660103895 - 0.023085974674888883im, 0.027973603660103895 - 0.023085974674888883im, 0.027973603660103895 - 0.023085974674888883im], [0.8697670118862033], 11.996369403338626, 1.0)


julia&gt; probability(result)
1-element Array{Float64,1}:
 0.8697670118862033</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/iitis/QuantumWalk.jl/blob/22b2061f668a3431fab4dcee997f27bf853b9831/src/qwdynamics/qwsearch/maximizing_function.jl#L4-L34">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumWalk.maximize_quantum_search-Tuple{QWSearch{#s3,W} where W&lt;:Real where #s3&lt;:QWModelDiscr}" href="#QuantumWalk.maximize_quantum_search-Tuple{QWSearch{#s3,W} where W&lt;:Real where #s3&lt;:QWModelDiscr}"><code>QuantumWalk.maximize_quantum_search</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">maximize_quantum_search(qws_discr [, runtime, mode])</code></pre><p>Determines optimal runtime for discrete quantum walk search. The time is searched in [0, runtime] interval, with penalty <code>penalty(qws_discr)</code>. It is recommended for penalty to be nonzero, otherwise time close 0 is returned. Typically small <code>penalty</code> approximately equal to log(n) is enough, but optimal value may depend on the model or graph chosen.</p><p>The optimal time depends on chosen <code>mode</code>:</p><ul><li><code>:firstmaxprob</code> stops when probability start to decrease,</li><li><code>:firstmaxeff</code> stops when expected runtime start to increase,</li><li><code>:maxtimeeff</code> chooses exhaustively the time from [0, runtime] with smallest expected time,</li><li><code>:maxtimeprob</code> chooses exhaustively the time from [0, runtime] with maximal success probability,</li><li><code>:maxeff</code> (default) finds optimal time with smallest expected time, usually faster than <code>:maxtimefff</code>.</li></ul><p>Note last three modes always returns optimal time within the interval.</p><p><code>maxtime</code> defaults to graph order n, <code>mode</code> defaults to <code>:maxeff</code>.</p><pre><code class="language-julia-repl">julia&gt; qws = QWSearch(Szegedy(complete_graph(200)), [1], 1);

julia&gt; result = maximize_quantum_search(qws);

julia&gt; runtime(result)
6

julia&gt; probability(result)
1-element Array{Float64,1}:
 0.5000160413993847

julia&gt; result = maximize_quantum_search(qws, 100, :maxtimeprob);

julia&gt; runtime(result)
39

julia&gt; probability(result)
1-element Array{Float64,1}:
 0.5509378780415133</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/iitis/QuantumWalk.jl/blob/22b2061f668a3431fab4dcee997f27bf853b9831/src/qwdynamics/qwsearch/maximizing_function.jl#L81-L122">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumWalk.penalty-Tuple{QWSearch}" href="#QuantumWalk.penalty-Tuple{QWSearch}"><code>QuantumWalk.penalty</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">penalty(qws)</code></pre><p>Returns <code>penalty</code> element of <code>qws</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/iitis/QuantumWalk.jl/blob/22b2061f668a3431fab4dcee997f27bf853b9831/src/qwdynamics/qwsearch/qwsearch.jl#L72-L76">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumWalk.penalty-Tuple{QSearchState}" href="#QuantumWalk.penalty-Tuple{QSearchState}"><code>QuantumWalk.penalty</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">penalty(qsearchstate)</code></pre><p>Returns the penalty time for which the state was calulated.</p></div></div><a class="source-link" target="_blank" href="https://github.com/iitis/QuantumWalk.jl/blob/22b2061f668a3431fab4dcee997f27bf853b9831/src/qwdynamics/qwsearch/qwsearch.jl#L145-L149">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumWalk.probability-Tuple{QSearchState}" href="#QuantumWalk.probability-Tuple{QSearchState}"><code>QuantumWalk.probability</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">probability(qsearchstate)</code></pre><p>Returns the list of probabilities of finding marked vertices.</p></div></div><a class="source-link" target="_blank" href="https://github.com/iitis/QuantumWalk.jl/blob/22b2061f668a3431fab4dcee997f27bf853b9831/src/qwdynamics/qwsearch/qwsearch.jl#L131-L135">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumWalk.runtime-Tuple{QSearchState}" href="#QuantumWalk.runtime-Tuple{QSearchState}"><code>QuantumWalk.runtime</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">runtime(qsearchstate)</code></pre><p>Returns the time for which the state was calulated.</p></div></div><a class="source-link" target="_blank" href="https://github.com/iitis/QuantumWalk.jl/blob/22b2061f668a3431fab4dcee997f27bf853b9831/src/qwdynamics/qwsearch/qwsearch.jl#L138-L142">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumWalk.state-Tuple{QSearchState}" href="#QuantumWalk.state-Tuple{QSearchState}"><code>QuantumWalk.state</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">state(qsearchstate)</code></pre><p>Returns the state of qsearchstate.</p></div></div><a class="source-link" target="_blank" href="https://github.com/iitis/QuantumWalk.jl/blob/22b2061f668a3431fab4dcee997f27bf853b9831/src/qwdynamics/qwsearch/qwsearch.jl#L124-L128">source</a></section><footer><hr/><a class="previous" href="../quantum_walk/"><span class="direction">Previous</span><span class="title">Quantum walk evolution</span></a><a class="next" href="../ctqw/"><span class="direction">Next</span><span class="title">CTQW and CTQWDense</span></a></footer></article></body></html>
